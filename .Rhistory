comb.list <- comb.list[-which(lengths(comb.list)==0)]
print(sum(sapply(comb.list, NROW)))
n_comb <- sapply(comb.list, NROW)
combination_list <- vector("list", sum(n_comb))
for (nnc in 1:length(comb.list)){
for (nns in 1:nrow(comb.list[[nnc]])){
combination_list[[sum(n_comb[1:nnc-1])+nns]] <- comb.list[[nnc]][nns, ]
}
}
saveRDS(combination_list, file = paste0("Combination/Combination.list.rds"))
devtools::build_site()
devtools::build_readme()
devtools::build_site()
devtools::build_manual()
devtools::build_site()
devtools::build_manual()
devtools::build_site
document()
devtools::document()
devtools::document()
devtools::build_site()
devtools::build_readme()
devtools::document()
devtools::build_site()
devtools::build_home()
devtools::build_readme()
devtoo
devtools::build_site()
devtools::build_readme()
devtools::build_site()
install.packages("Hmisc")
install.packages(c("cowplot", "Hmisc"))
devtools::document()
library(devtools)
getwd()
library(devtools)
devtools::document()
devtools::build_readme()
devtools::build_site()
devtools::build_readme()
devtools::build_site()
devtools::document()
devtools::build_readme()
devtools::build_vignettes()
devtools::build_site()
devtools::install_github("benenns/LEMpackTEST")
library(LEMpackHIV)
getwd()
devtools::build_readme()
devtools::build_readme()
devtools::document()
devtools::build_site()
devtools::install_github("HERU-LEM/LEMpackHIV")
devtools::install_github("benenns/LEMpackTEST")
devtools::install_github("benenns/LEMpackTEST")
# Run model and accumulate outcomes (deterministic)
# This module allows for city selection, loads list of intervention combinations, loads ordinary differential equation functions,
# analysis scenario (deterministic or sensitivity analysis), and loads input parameters and comparators.
# It also provides code for running parallel estimations.
#############################################################################
# 1. SET directory and workspace
#############################################################################
rm(list=ls())
library(rstudioapi)
library(LEMpackHIV)
#setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("01_Setup/CascadeCEA-Interventions-1-LoadBaselineWorkspace.R")
# SELECT city ##
CITY <- select.list(all.cities, multiple = FALSE,
title = 'Select city', graphics = FALSE)
# Run model and accumulate outcomes (deterministic)
# This module allows for city selection, loads list of intervention combinations, loads ordinary differential equation functions,
# analysis scenario (deterministic or sensitivity analysis), and loads input parameters and comparators.
# It also provides code for running parallel estimations.
#############################################################################
# 1. SET directory and workspace
#############################################################################
rm(list=ls())
library(rstudioapi)
library(LEMpackHIV)
#setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("01_Setup/CascadeCEA-Interventions-1-LoadBaselineWorkspace.R")
# SELECT city ##
CITY <- select.list(all.cities, multiple = FALSE,
title = 'Select city', graphics = FALSE)
## LOAD list of all combinations, interventions indexed by number in each combination
# if the list does not exist, source("CascadeCEA-Combination-0-Setup-combination.list.R")
combination.list <- readRDS("Combination/Combination.list.rds")
## LOAD analysis scenario
case = "DM"  # DM for deterministic, SA for sensitivity analysis
## LOAD all input parameters and comparators
source("01_Setup/CascadeCEA-Interventions-1-LoadParameterWorkspace-Combination.R")
total.comb <- length(combination.list)
tic("Model run")
## LOAD all input parameters and comparators
source("01_Setup/CascadeCEA-Interventions-1-LoadParameterWorkspace-Combination.R")
getwd()
source("01_Setup/CascadeCEA-Model-1-Module-Data.input.R")
source ("01_Setup/CascadeCEA-Model-0-Parameter.update.R")
################################################################################
## DATA INPUT                                                                 ##
################################################################################
## Read in data from excel file ##
if (exists("int.scale")){
myFile.name <- c("Data Files/Ideal/Evidence-Inputs-Master-Ideal")
} else {
myFile.name <- c("Data Files/Evidence-Inputs-Master")
}
WB <- loadWorkbook(paste0(myFile.name,".xlsx"))
updated.prep2020 <- read.csv("Data Files/LEMmodel-UpdatedPrEPdata2020.csv")[, c(1:6)]
colnames(updated.prep2020) <- c("city","year","pe","low","hi","coverage")
updated.prep2020 <- na.omit(updated.prep2020)
par_info      <- read.xlsx(WB, sheet="parameter_info")  #first tab "parameter_info" for parameter info, e.g. name, dimension
vlist         <- list()                                 #initialize intermediate vlist (as a list) to save inputs
length(vlist) <- nrow(par_info)                         #number of input parameters
names (vlist) <- par_info$parameter                     #name of input parameters
vparameters   <- vlist                                  #initialize vparameters - parameter list used in model
city_sp     <- grep('Y', par_info$city_specific)        #City-specific parameters
non_city_sp <- grep('N', par_info$city_specific)        #Non-city-specific parameters
uncert      <- grep('Y', par_info$uncertain)            #Uncertain parameters
cert        <- grep('N', par_info$uncertain)            #Parameters fixed in next steps
## Parametrization for single-dimension parameters, i.e. dimension = 1
#city-scpecific parameters
for (i in city_sp){
vlist[[i]] = subset(read.xlsx(WB, sheet=par_info$tab[i]), city == CITY)[ ,-1]
if (par_info[i, ]$dimension == 1){
vparameters[[i]] = vlist[[i]]$pe
}
}
#non-city-scpecific parameters
for (i in non_city_sp){
vlist[[i]] = read.xlsx(WB, sheet=par_info$tab[i])
if (par_info[i, ]$dimension == 1){
vparameters[[i]] = vlist[[i]]$pe
}
}
## String variables for variable/group/target names
if (CITY != "MIA"){
namelist   = read.xlsx(WB, sheet="common")
} else {
namelist   = read.xlsx(WB, sheet="common_MIA")
}
names.gp   = namelist$names.gp                                 #group names, 42 groups: fullly stratified 42 groups
names18    = namelist$names18[!is.na(namelist$names18)]        #group names, 18 groups: gender*risk group*ethnicity (aggregate)
names.pwid = namelist$names.pwid[!is.na(namelist$names.pwid)]  #group names, 9 PWID groups: gender*risk group*ethnicity (aggregate)
names.msm  = namelist$names.msm[!is.na(namelist$names.msm)]    #group names, 18 MSM and MWID groups: gender*risk group*ethnicity * risk level * OAT (fully stratified)
names.e    = namelist$names.e[!is.na(namelist$names.e)]        #group names, 6 groups: high/low*ethnicity (highly aggregate)
state.name = c("S1", "S2", "Sp", "Ia", "I1", "I2", "I3", "Iap", "Ip",
"Da", "D1", "D2", "D3", "T1", "T2", "T3", "O1",  "O2", "O3",
"inc_bo", "inc_bs", "inc_g", "diag", "death")   #names for the 19 health states
vparameters = c(vparameters, as.data.frame(names.gp), as.data.frame(names18), as.data.frame(names.pwid), as.data.frame(names.msm), as.data.frame(names.e), as.data.frame(state.name))
# Add string variables in vparameters
source("01_Setup/CascadeCEA-Model-0-Group.number.R")
## Parametrization for parameters with multiple dimensions
source("01_Setup/CascadeCEA-Model-0-Parameterization.R")
## Weight vectors distinct for MIA (fewer targets) and SEA (adjustment for black), only used in calibration
if (CITY != "SEA" & CITY != "MIA"){
vparameters$w = with(vlist$w, pe[city == "other"])
} else if (CITY == "SEA"){
vparameters$w = with(vlist$w, pe[city == "SEA"])
} else {
vparameters$w = with(vlist$w, pe[city == "MIA"])
}
vparameters = vparameters[-which(sapply(vparameters, is.null))]
## Read in target (calibration and validation) data ##
diag18.obs  = data.matrix(subset(data.frame(read.xlsx("Data Files/Target.xlsx", sheet="diag18.obs",  colNames =T)), city == CITY)[ , -1]) #total diagnosed cases, 18 groups
ndiag18.obs = data.matrix(subset(data.frame(read.xlsx("Data Files/Target.xlsx", sheet="ndiag18.obs", colNames =T)), city == CITY)[ , -1]) #new diagnoses, 18 groups
death18.obs = data.matrix(subset(data.frame(read.xlsx("Data Files/Target.xlsx", sheet="death18.obs", colNames =T)), city == CITY)[ , -1]) #all-casue deaths, 18 groups
obs.inc.all = subset(data.frame(read.xlsx("Data Files/Target.xlsx", sheet="inc.all.obs", colNames =T)), city == CITY)[ , -1]              #new incidence, total and range
obs.inc.msm = subset(data.frame(read.xlsx("Data Files/Target.xlsx", sheet="inc.msm.obs", colNames =T)), city == CITY)[ , -1]              #new incidence, MSM and range
## Derive model initials ##
source("01_Setup/CascadeCEA-Model-0-Function-model.initial.R")
init  = model.initial(par = vparameters, diag18 = diag18.obs[1, ])  #42*19 initials
inits = cbind(init, inc_bo=0, inc_bs=0, inc_g=0, diag=0, death=0)   #adding states to track # infections (by 3 routes of transmission), new diagnoses and deaths among PLHIV
x     = as.vector(t(inits))                                         #ode function requires init as vector (x)
vparameters$init.group.prop = as.vector(rowSums(init)/sum(init))
## initial population for 18 groups (collapsing onOAt/offOAT, low/high)
init.collap   = numeric(18)
rname = gsub(paste(c("/OAT","/low","/high"), collapse="|"), "", names.gp)
for (i in 1:18){
ind = which(rname %in% names18[i])
init.collap[i] = sum(init[ind, ])
}
vparameters$prop.adj     = TRUE     # force the risk group proportions to remain constant
vparameters$inf.prop.adj = TRUE     # force the risk level proportions to remain constant among infected
vparameters$bal          = TRUE     # balance # of sexual parnership between males & females
## These two variables are required for estimating OAT and PrEP entry rates in ODE module (only use initial values) ##
vparameters$pop.pwid   = init.collap[grep("PWID", names18)]                       # number of PWID (include MWID) within the 9 collapsed groups
vparameters$msm.h.scep = rowSums(matrix(rowSums(inits[msm.h , 1:3]), nrow=3))  # number of high-risk MSM (include MWID) within the 3 collapsed groups (race only)
#prep.coverage <- matrix(unlist(lapply(prep.by.year, function(x) x*prep.proportion/vparameters$msm.h.scep)), nrow=length(prep.by.year), byrow=TRUE)
#rownames(prep.coverage) <- names(coverage.by.year)
#colnames(prep.coverage) <- c("w","b","h")
#vparameters$prep.coverage <- prep.coverage
## READ in free parameters ##
calpar  = read.xlsx("Data Files/cali_par_all.xlsx", sheet=CITY)  # Load free parameters
calpar.info = as.list(2)                              # To save information for free.par
calpar.info$names   = unique(calpar$par)              # names of free.par
calpar.info$plength = as.numeric(table(factor(calpar$par, levels=calpar.info$names))) # length of each free.par
source ("01_Setup/CascadeCEA-Model-0-Parameter.update.R")
source("01_Setup/CascadeCEA-Model-1-Module-Data.input.R")
### GET CALIBRATED PARAMETER SETS
if (case == "DM"){     #For the case of deterministic analysis based on the mean value of calibrationed parameters
Int.Scale.ls   <- setNames(lapply(ls(pattern="^IntScale."), get), ls(pattern="^IntScale."))
Int.Eff.ls     <- setNames(lapply(ls(pattern="^IntEff."), get), ls(pattern="^IntEff."))
Int.Costs.ls   <- setNames(lapply(ls(pattern="^IntCosts."), get), ls(pattern="^IntCosts."))
State.Costs.ls <- setNames(lapply(ls(pattern="^StateCosts."), get), ls(pattern="^StateCosts."))
All.Costs.ls   <- c(Int.Costs.ls, State.Costs.ls)
if(file.exists(paste0("Inputs/AllParams-Combination-DM-", CITY, ".rds"))){
all.params   <- readRDS(paste0("Inputs/AllParams-Combination-DM-", CITY, ".rds"))
} else if (!file.exists(paste0("Inputs/AllParams-Combination-DM-", CITY, ".rds"))){
calib.params.ls <- readRDS(paste0("Inputs/Calib-Outputs-", CITY, ".rds"))   # Calibrated values for free parameter
calib.params    <- calib.params.ls[[3]]
calpar$pe = rowMeans(calib.params)
if (CITY == "BAL"){
calpar$pe[5] = 0.77  # Calibrated values for this parameter is bimodally distributed in Baltimore
}
source ("01_Setup/CascadeCEA-Model-0-Parameter.update.R")  # Update free parameters with the mean calibrated values
all.params <- vparameters
rm(calib.params.ls, calib.params)
saveRDS(all.params, paste0("Inputs/AllParams-Combination-DM-", CITY, ".rds"))
}
all.params$move.pop.adj = TRUE     # adjust the population size of corresponding compartment at the end of each time step to maintain designated proportions in the given health state
## These are move.pop.adj trigger levels
all.params$I.PLHIV.adj.level = 0.05
all.params$D.PLHIV.adj.level = 0.05
all.params$ART.PLHIV.adj.level = 0.95
all.params$move.start = 1
all.params$move.end = 10000
} else if (case == "SA"){
Int.Scale.ls        <- setNames(lapply(ls(pattern="^IntScale."), get), ls(pattern="^IntScale."))
All.Costs.ls.list   <- readRDS(paste0("PSA/", CITY, "-All.Costs.rds"))
State.QALYs.ls.list <- readRDS(paste0("PSA/", CITY, "-StateQALYs.rds"))
Int.Baseline.ls.list<- readRDS(paste0("PSA/", CITY, "-IntBaseline.rds"))
Int.Eff.ls.list     <- readRDS(paste0("PSA/", CITY, "-IntEff.rds"))
if(file.exists(paste0("Inputs/AllParams-Combination-SA-", CITY, ".rds"))){
all.params.list   <- readRDS(paste0("Inputs/AllParams-Combination-SA-", CITY, ".rds"))
} else if (!file.exists(paste0("Inputs/AllParams-Combination-SA-", CITY, ".rds"))){
all.params.list   <- readRDS(paste0("PSA/", CITY, "-vparameters.rds"))
saveRDS(all.params.list, paste0("Inputs/AllParams-Combination-SA-", CITY, ".rds"))
}
}
#############################################################################
# 2. LOAD CITY COMPARATOR (Status Quo)
#############################################################################
# STATUS QUO (NAMING OF READ IN FILES TO BE UPDATED)
if (case == "DM"){
if(file.exists(paste0("Inputs/Combination-DM-", CITY, "-refcase.rds"))){    # all population list of each compartment at each step
## Load reference case
refcase.ls <- readRDS(paste0("Inputs/Combination-DM-", CITY, "-refcase.rds"))
if(file.exists(paste0("Inputs/Combination-DM-", CITY, "-refcase-outcomes.rds"))){  # CEA outcomes of deterministic case
refcase.cea.utcomes <- readRDS(paste0("Inputs/Combination-DM-", CITY, "-refcase-outcomes.rds"))
} else if(!file.exists(paste0("Inputs/Combination-DM-", CITY, "-refcase-outcomes.rds"))){
warning("Reference case outcomes data are missing")
}
if(file.exists(paste0("Inputs/Combination-DM-", CITY, "-refcase-infections.rds"))){ # Incidence outcomes of deterministic case
refcase.infs <- readRDS(paste0("Inputs/Combination-DM-", CITY, "-refcase-infections.rds"))
} else if(!file.exists(paste0("Inputs/Combination-DM-", CITY, "-refcase-infections.rds"))){
warning("Reference case infections data are missing")
}
} else if (!file.exists(paste0("Inputs/Combination-DM-", CITY, "-refcase.rds"))){
## Settings for reference
refcase.ls <- intervention.model.combination (input.parameters = all.params,
current.int      = c("No interventions"))
## ACCUMULATE COSTS & QALYs
refcase.cea.outcomes <- accum.outcomes.combination (input.parameters = all.params,
pop.in           = refcase.ls[, 1:19, ],
current.int      = c("No interventions"),
sums.only        = TRUE)
# Get number of infections over the evaluation period
refcase.infs <- time.period.infections(simul.in     = refcase.ls,
start.period = start.proj,
end.period   = end.proj,
sust.period  = int.sus)
### SAVE REFERENCE OUTCOMES
saveRDS(refcase.ls,           paste0("Inputs/Combination-DM-", CITY, "-refcase.rds"))
saveRDS(refcase.cea.outcomes, paste0("Inputs/Combination-DM-", CITY, "-refcase-outcomes.rds"))
saveRDS(refcase.infs,         paste0("Inputs/Combination-DM-", CITY, "-refcase-infections.rds"))
}
} else if (case == "SA"){
if(file.exists(paste0("Inputs/Combination-SA-", CITY, "-refcase-outcomes.rds"))){
refcase.cea.outcomes.temp <- readRDS(paste0("Inputs/Combination-SA-", CITY, "-refcase-outcomes.rds"))
if(file.exists(paste0("Inputs/Combination-SA-", CITY, "-refcase-infections.rds"))){
refcase.infs.temp <- readRDS(paste0("Inputs/Combination-SA-", CITY, "-refcase-infections.rds"))
refcase.infs      <- refcase.infs.temp[1 : param.sets]
rm(refcase.infs.temp)
} else if(!file.exists(paste0("Inputs/Combination-SA-", CITY, "-refcase-infections.rds"))){
warning("Reference case infections data are missing")
}
refcase.cea.outcomes <- refcase.cea.outcomes.temp[1:param.sets]
rm(refcase.cea.outcomes.temp)
} else if (!file.exists(paste0("Inputs/Combination-SA-", CITY, "-refcase-outcomes.rds"))){
if (file.exists(paste0("Inputs/", CITY, "-2040-refcase.rds"))){      #list restoring the population lists of reference case from 2000 PSA: >4GB
refcase.ls.temp <- readRDS(paste0("Inputs/", CITY, "-2040-refcase.rds"))
} else if (!file.exists(paste0("Inputs/", CITY, "-2040-refcase.rds"))){
refcase.ls.temp <- foreach(kk=1:param.sets, .export = export.int.model.names
) %dopar% {
out.ls.int <- intervention.model.combination(
input.parameters = all.params.list[[kk]],
current.int = c("No interventions"))
}
saveRDS(refcase.ls.temp, paste0("Inputs/", CITY, "-2040-refcase.rds"))
}
refcase.infs         <- vector("list", param.sets)
refcase.cea.outcomes <- vector("list", param.sets)
for(p in 1:param.sets){
## Set parameters
refcase.pop       <- refcase.ls.temp[[p]]
refcase.infs[[p]] <- time.period.infections (simul.in     = refcase.pop,
start.period = start.proj,
end.period   = end.proj,
sust.period  = int.sus)
## Set parameters
all.params         <- all.params.list[[p]]
StateQALYs         <- State.QALYs.ls.list[[p]]
#These were unused in PSA for reference case but required by the function
All.Costs.ls       <- All.Costs.ls.list[[p]]
Int.Baseline.ls    <- Int.Baseline.ls.list[[p]]
Int.Eff.ls         <- Int.Eff.ls.list[[p]]
## ACCUMULATE COSTS & QALYs
refcase.cea.outcomes[[p]] <- accum.outcomes.combination(input.parameters = all.params,
pop.in           = refcase.pop[, 1:19, ],
current.int      = c("No interventions"),
sums.only        = TRUE)
}
saveRDS(refcase.infs,         paste0("Inputs/Combination-SA-", CITY, "-refcase-infections.rds"))
saveRDS(refcase.cea.outcomes, paste0("Inputs/Combination-SA-", CITY, "-refcase-outcomes.rds"))
}
} #END "SA"/"DM" Loop
# Clean workspace by using lists for scale & costs (rm at end of file)
rm(list = ls(pattern = "(^IntCosts.)|(^StateCosts.)|(^IntScale.)|(^IntEff.)"))
## LOAD all input parameters and comparators
source("01_Setup/CascadeCEA-Interventions-1-LoadParameterWorkspace-Combination.R")
total.comb <- length(combination.list)
tic("Model run")
outcome.comb.mx <- matrix(0, nrow = total.comb, ncol = 44)    ##Initialize combination outcome matrix (to save results)
outcome.comb.mx <- foreach(cc=1:total.comb, .combine=rbind, .export = export.int.model.names
) %dopar% {
comb.eva.func(input.parameters = all.params, current.int = interventions[combination.list[[cc]]])
}
future:::ClusterRegistry("stop")   ##Stop parallel estimations and free cores
colnames(outcome.comb.mx)        <- rep("FILL", 44)
colnames(outcome.comb.mx)[1:6]   <- c("Infections.total-20Y", "SuscPY-over20Y", "Infections.total-10Y", "SuscPY-over10Y", "Infections.total-5Y", "SuscPY-over5Y")
colnames(outcome.comb.mx)[7:32]  <- paste0("Year", c(2015:2040))
colnames(outcome.comb.mx)[33:44] <- c("QALYs.sum", "costs.total.sum", "costs.hru.sum", "costs.art.sum", "costs.art.ini.sum",
"costs.oat.sum", "costs.prep.sum", "costs.prep.tests.sum", "costs.test.sum", "int.costs.sum",
"int.impl.costs.sum", "int.sust.costs.sum")
saveRDS(outcome.comb.mx,   paste0("Combination/Outcome-All-Combination-", CITY, "-DM.rds"))
toc()
# Run model and accumulate outcomes (deterministic and PSA, for optimal combination implmentation strategy identifed at documented scale)
# This module allows users to run deterministic and PSA for optimal combination implementation strategy at documented scale
# PREREQUISITE: run documented and determine the production function first
#############################################################################
# 1. SET directory and workspace
#############################################################################
rm(list=ls())
library(rstudioapi)
library(LEMpackHIV)
#setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("01_setup/CascadeCEA-Interventions-1-LoadBaselineWorkspace.R")
# SELECT city ##
CITY <- select.list(all.cities, multiple = FALSE,
title = 'Select city', graphics = FALSE)
#############################################################################
## Cascade CEA Model - Combination Interventions
## Produce the CEA table comparing the OCIS with the comparator, with 95% CI
## Last update: March 16, 2020
#############################################################################
############################################################################################
rm(list=ls())
library(rstudioapi)
library(LEMpackHIV)
#setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("01_Setup/CascadeCEA-Interventions-1-LoadBaselineWorkspace.R")
cea.table           <- matrix(0, ncol = 11, nrow = 6)
colnames(cea.table) <- c("IncrementalCost_pe", "IncrementalCost_low", "IncrementalCost_up",
"IncrementalQALY_pe", "IncrementalQALY_low", "IncrementalQALY_up",
"ICER_pe", "ICER_low", "ICER_up", "%cost-effective", "%cost-saving")
rownames(cea.table) <- c("Atlanta", "Baltimore", "Los Angeles", "Miami", "New York City", "Seattle")
CEthreshold         <- 100000
city.name.list      <- c("Atlanta", "Baltimore", "Los Angeles", "Miami", "New York City", "Seattle")
combination.list    <- readRDS("Combination/Combination.list.rds")
for (ww in 1:6){
CITY       <- all.cities[ww]
CITY.name  <- city.name.list[ww]
frontier   <- readRDS(paste0("Combination/ProductionFunction-Frontier-", CITY, ".rds"))$frontier
ocis       <- readRDS(paste0("Combination/ProductionFunction-Frontier-", CITY, ".rds"))$ocis
comparator <- readRDS(paste0("Combination/ProductionFunction-Frontier-", CITY, ".rds"))$comparator
#Derministic results
outcome.comb   <- readRDS(paste0("Combination/Outcome-All-Combination-", CITY, "-DM.rds"))
comp.matrix    <- outcome.comb[c(comparator, ocis) , c("QALYs.sum", "costs.total.sum")]
#PSA results
ocis.mx         <- readRDS(paste0("Combination/Outcome-Combination-", CITY, "-PSA-", ocis,"(OCIS).rds"))[ , c("QALYs.sum", "costs.total.sum")]
comparator.mx   <- readRDS(paste0("Combination/Outcome-Combination-", CITY, "-PSA-", comparator,"(Comparator).rds"))[ , c("QALYs.sum", "costs.total.sum")]
outcome.SA.ref  <- readRDS(paste0("Inputs/Combination-SA-", CITY, "-refcase-outcomes.rds"))
ref.matrix      <- matrix(0, nrow = 2000, ncol =2)
ref.matrix[ ,1] <- unlist(lapply(outcome.SA.ref, "[[", 1))
ref.matrix[ ,2] <- unlist(lapply(outcome.SA.ref, "[[", 2))
####in comparison to next best ####
quantile((ocis.mx[ , "costs.total.sum"] - ref.matrix[ ,2]), c(0.025, 0.975)) / 1000000
quantile((ocis.mx[ , "QALYs.sum"] - ref.matrix[ ,1]), c(0.025, 0.975))
cost.col <- 2; qaly.col <-1
cea.table[CITY.name, "IncrementalCost_pe"] <- comp.matrix[2, cost.col] - comp.matrix[1, cost.col]
cea.table[CITY.name, c("IncrementalCost_low", "IncrementalCost_up")] <- quantile((ocis.mx[ , "costs.total.sum"] - comparator.mx[ , "costs.total.sum"]), c(0.025, 0.975))
cea.table[CITY.name, "IncrementalQALY_pe"] <- comp.matrix[2, qaly.col] - comp.matrix[1, qaly.col]
cea.table[CITY.name, c("IncrementalQALY_low", "IncrementalQALY_up")] <- quantile((ocis.mx[ , "QALYs.sum"] - comparator.mx[ , "QALYs.sum"]), c(0.025, 0.975))
cea.table[CITY.name, "ICER_pe"] <- (comp.matrix[2, cost.col] - comp.matrix[1, cost.col]) / (comp.matrix[2, qaly.col] - comp.matrix[1, qaly.col])
cea.table[CITY.name, c("ICER_low", "ICER_up")] <- quantile((ocis.mx[ , "costs.total.sum"] - comparator.mx[ , "costs.total.sum"]) /
(ocis.mx[ , "QALYs.sum"] - comparator.mx[ , "QALYs.sum"]), c(0.025, 0.975))
cea.table[CITY.name, "%cost-effective"] <- sum(((ocis.mx[ , "costs.total.sum"] - comparator.mx[ , "costs.total.sum"]) /
(ocis.mx[ , "QALYs.sum"] - comparator.mx[ , "QALYs.sum"])) < CEthreshold) / 2000   # %cost-effective
cea.table[CITY.name, "%cost-saving"]    <- length(which(ocis.mx[ , "costs.total.sum"] - ref.matrix[ , cost.col] < 0)) / 2000   # %cost-saving
}
write.csv(cea.table,'Outputs/CEA Table/CEATable(range).csv')
#############################################################################################
## Cascade CEA Model - Combination Interventions
## Plot production functions in a 6-panel graph
## Last updated: March 11, 2020
############################################################################################
rm(list=ls())
library(rstudioapi)
library(Hmisc)
library(LEMpackHIV)
#setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
CITY.list <- c("ATL", "BAL", "LA", "MIA", "NYC", "SEA")
CITY.name <- c("(A) Atlanta", " (B) Baltimore", "(C) Los Angeles", "(D) Miami", "(E) New York City", "(F) Seattle")
par(mfrow = c(3, 2))
par(mar=c(3.8,3.8,1,1), oma = c(1, 1, 1, 1))
for (cc in 1:6){
CITY <- CITY.list[cc]
source("01_Setup/CascadeCEA-Interventions-1-LoadBaselineWorkspace.R")
combination.list <- readRDS("Combination/Combination.list.rds")
frontier         <- readRDS(paste0("Combination/ProductionFunction-Frontier-", CITY, ".rds"))$frontier
ocis             <- readRDS(paste0("Combination/ProductionFunction-Frontier-", CITY, ".rds"))$ocis
outcome.comb     <- readRDS(paste0("Combination/Outcome-All-Combination-", CITY, "-DM.rds"))
outcome.ref      <- unlist(readRDS(paste0("Inputs/Combination-DM-", CITY, "-refcase-outcomes.rds")))
frontier.matrix  <- rbind(outcome.ref[c("QALYs.sum", "costs.total.sum")], outcome.comb[frontier , c("QALYs.sum", "costs.total.sum")])
Strategy.ind     <- c(0, frontier)
frontier.matrix  <- cbind(Strategy.ind, frontier.matrix)
costsCol <- 3; qalyCol <- 2
#frontier matrix, first row is reference case
frontier.matrix[ , qalyCol]  <- frontier.matrix[ , qalyCol] - frontier.matrix[1, qalyCol]
frontier.matrix[ , costsCol] <- frontier.matrix[ , costsCol] - frontier.matrix[1, costsCol]
frontier.matrix  <- frontier.matrix[-1, ]  #remove the reference case
frontier.matrix[ , costsCol] <- frontier.matrix[ , costsCol] / 1000000
#matrix for other dominated strategies
other_comb          <- outcome.comb[-frontier , c("QALYs.sum", "costs.total.sum")]
other_comb.mx       <- other_comb
other_comb.mx[ , 1] <- other_comb.mx[ , 1] - outcome.ref["QALYs.sum"]
other_comb.mx[ , 2] <- other_comb.mx[ , 2] - outcome.ref["costs.total.sum"]
other_comb.mx[ , 2] <- other_comb.mx[ , 2] / 1000000
xlim <- c(min(frontier.matrix[ , costsCol]) *1.2, max(other_comb.mx[ , 2]* 1.02))
ylim <- c(0 , max(frontier.matrix[ , qalyCol])*1.25)
plot(frontier.matrix[ , costsCol],  frontier.matrix[ , qalyCol], col = adjustcolor("dodgerblue", alpha = 0.8) , pch = 16, xlab="Incremental cost, versus statuo quo (US$, million)", ylab="Incremental QALYs, versus status quo", xlim=xlim, ylim=ylim, cex=1.2, cex.axis=0.95)
points(other_comb.mx[,2], other_comb.mx[,1], col = adjustcolor("lightgrey", alpha = 0.5), pch=16, cex = 0.5)
points(frontier.matrix[ , costsCol],  frontier.matrix[ , qalyCol], col = adjustcolor("dodgerblue", alpha = 0.8) , pch = 16)
lines(frontier.matrix[ , costsCol], frontier.matrix[ , qalyCol], col = adjustcolor("dodgerblue", alpha = 0.8), lwd=2)
points(frontier.matrix[which(frontier == ocis) , costsCol],  frontier.matrix[which(frontier == ocis) , qalyCol], col = adjustcolor("firebrick2", alpha = 1) , cex = 1.25, pch = 16)
abline(v = 0, lty=3, col = "grey")
title(CITY.name[cc], adj = 0.02, line = - 1)
minor.tick(nx=2, ny=2)
legend(x="bottomright",
legend=c(paste0("OCIS (", CITY, ")"), "Strategies on PF","Other strategies"),
col=c("dodgerblue","firebrick2", "lightgrey"),
lwd=c(1.2, 1, 0.5), lty = c(1, NA, NA), pch=c(16, 16,16), pt.cex = c(1,1.1,1), cex = 0.8, bty = "n")
}
#############################################################################################
## Cascade CEA Model - Combination Interventions (Core)
## Derive the disaggregated cost estimates of selected OCIS for each city
## Last updated: March 15, 2020
############################################################################################
rm(list=ls())
library(rstudioapi)
library(LEMpackHIV)
#setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("01_Setup/CascadeCEA-Interventions-1-LoadBaselineWorkspace.R")
## LOAD ODE function
#source("R/CascadeCEA-Model-0-Function-ode_model-Combination.R")
## SELECT city ##
CITY <- select.list(all.cities, multiple = FALSE,
title = 'Select city', graphics = FALSE)
# ww= 1; CITY <- all.cities[ww]
## LOAD inputs and ntervention ##
case             <- "DM"  # DM for deterministic, SA for sensitivity analysis
load.status.quo  <- TRUE
sums.only        <- FALSE
Discounting      <- 0.03
combination.list <- readRDS("Combination/Combination.list.rds")
ocis             <- readRDS(paste0("Combination/ProductionFunction-Frontier-", CITY, ".rds"))$ocis
source("01_Setup/CascadeCEA-Interventions-1-LoadParameterWorkspace-Combination.R")
current.int = interventions[combination.list[[ocis]]]
## RUN the model ##
out.ls.int <- intervention.model.combination(input.parameters = all.params,
current.int = current.int)
out.ls.accum.int <- accum.outcomes.combination(input.parameters = all.params,
pop.in           = out.ls.int[, 1:19, ],
current.int      = current.int,
sums.only        = sums.only)
saveRDS(out.ls.accum.int, paste0("Outputs/CostBreakdown/CostBreakdown-", CITY, "-Strategy-", ocis,"-documented.rds"))
devtools::document()
devtools::document()
getwd()
devtools::build_site()
backports::
require(devtools)
install_version("backports", version = "1.1.0")
library(backports)
install.packages("backports")
devtools::document()
install.packages("backports")
devtools::document()
devtools::build_readme()
devtools::build_site()
